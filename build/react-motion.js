(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? factory(exports, require('react'))
    : typeof define === 'function' && define.amd
    ? define(['exports', 'react'], factory)
    : factory((global.ReactMotion = {}), global.React);
})(this, function(exports, React) {
  'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  function _extends() {
    _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  // currently used to initiate the velocity style object to 0
  function mapToZero(obj) {
    var ret = {};

    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        ret[key] = 0;
      }
    }

    return ret;
  }

  // turn {x: {val: 1, stiffness: 1, damping: 2}, y: 2} generated by
  // `{x: spring(1, {stiffness: 1, damping: 2}), y: 2}` into {x: 1, y: 2}
  function stripStyle(style) {
    var ret = {};

    for (var key in style) {
      if (!Object.prototype.hasOwnProperty.call(style, key)) {
        continue;
      }

      ret[key] = typeof style[key] === 'number' ? style[key] : style[key].val;
    }

    return ret;
  }

  // stepper is used a lot. Saves allocation to return the same array wrapper.
  // This is fine and danger-free against mutations because the callsite
  // immediately destructures it and gets the numbers inside without passing the
  // array reference around.
  var reusedTuple = [0, 0];
  function stepper(secondPerFrame, x, v, destX, k, b, precision) {
    // Spring stiffness, in kg / s^2
    // for animations, destX is really spring length (spring at rest). initial
    // position is considered as the stretched/compressed position of a spring
    var Fspring = -k * (x - destX); // Damping, in kg / s

    var Fdamper = -b * v; // usually we put mass here, but for animation purposes, specifying mass is a
    // bit redundant. you could simply adjust k and b accordingly
    // let a = (Fspring + Fdamper) / mass;

    var a = Fspring + Fdamper;
    var newV = v + a * secondPerFrame;
    var newX = x + newV * secondPerFrame;

    if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {
      reusedTuple[0] = destX;
      reusedTuple[1] = 0;
      return reusedTuple;
    }

    reusedTuple[0] = newX;
    reusedTuple[1] = newV;
    return reusedTuple;
  }

  var commonjsGlobal =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : typeof self !== 'undefined'
      ? self
      : {};

  function createCommonjsModule(fn, module) {
    return (
      (module = { exports: {} }), fn(module, module.exports), module.exports
    );
  }

  var performanceNow = createCommonjsModule(function(module) {
    // Generated by CoffeeScript 1.12.2
    (function() {
      var getNanoSeconds,
        hrtime,
        loadTime,
        moduleLoadTime,
        nodeLoadTime,
        upTime;

      if (
        typeof performance !== 'undefined' &&
        performance !== null &&
        performance.now
      ) {
        module.exports = function() {
          return performance.now();
        };
      } else if (
        typeof process !== 'undefined' &&
        process !== null &&
        process.hrtime
      ) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }.call(commonjsGlobal));
  });

  var performanceNow$1 = createCommonjsModule(function(module) {
    // Generated by CoffeeScript 1.12.2
    (function() {
      var getNanoSeconds,
        hrtime,
        loadTime,
        moduleLoadTime,
        nodeLoadTime,
        upTime;

      if (
        typeof performance !== 'undefined' &&
        performance !== null &&
        performance.now
      ) {
        module.exports = function() {
          return performance.now();
        };
      } else if (
        typeof process !== 'undefined' &&
        process !== null &&
        process.hrtime
      ) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }.call(commonjsGlobal));
  });

  var root = typeof window === 'undefined' ? commonjsGlobal : window,
    vendors = ['moz', 'webkit'],
    suffix = 'AnimationFrame',
    raf = root['request' + suffix],
    caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

  for (var i = 0; !raf && i < vendors.length; i++) {
    raf = root[vendors[i] + 'Request' + suffix];
    caf =
      root[vendors[i] + 'Cancel' + suffix] ||
      root[vendors[i] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if (!raf || !caf) {
    var last = 0,
      id = 0,
      queue = [],
      frameDuration = 1000 / 60;

    raf = function(callback) {
      if (queue.length === 0) {
        var _now = performanceNow$1(),
          next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for (var i = 0; i < cp.length; i++) {
            if (!cp[i].cancelled) {
              try {
                cp[i].callback(last);
              } catch (e) {
                setTimeout(function() {
                  throw e;
                }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false,
      });
      return id;
    };

    caf = function(handle) {
      for (var i = 0; i < queue.length; i++) {
        if (queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  var raf_1 = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn);
  };
  var cancel = function() {
    caf.apply(root, arguments);
  };
  var polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
  raf_1.cancel = cancel;
  raf_1.polyfill = polyfill;

  // usage assumption: currentStyle values have already been rendered but it says
  // nothing of whether currentStyle is stale (see unreadPropStyle)
  function shouldStopAnimation(currentStyle, style, currentVelocity) {
    for (var key in style) {
      if (!Object.prototype.hasOwnProperty.call(style, key)) {
        continue;
      }

      if (currentVelocity[key] !== 0) {
        return false;
      }

      var styleValue =
        typeof style[key] === 'number' ? style[key] : style[key].val; // stepper will have already taken care of rounding precision errors, so
      // won't have such thing as 0.9999 !=== 1

      if (currentStyle[key] !== styleValue) {
        return false;
      }
    }

    return true;
  }

  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var reactIs_development = createCommonjsModule(function(module, exports) {
    {
      (function() {
        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.
        var hasSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol
          ? Symbol.for('react.element')
          : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol
          ? Symbol.for('react.fragment')
          : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol
          ? Symbol.for('react.strict_mode')
          : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol
          ? Symbol.for('react.profiler')
          : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol
          ? Symbol.for('react.provider')
          : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol
          ? Symbol.for('react.context')
          : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
        // (unstable) APIs that have been removed. Can we remove the symbols?

        var REACT_ASYNC_MODE_TYPE = hasSymbol
          ? Symbol.for('react.async_mode')
          : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol
          ? Symbol.for('react.concurrent_mode')
          : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol
          ? Symbol.for('react.forward_ref')
          : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol
          ? Symbol.for('react.suspense')
          : 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol
          ? Symbol.for('react.suspense_list')
          : 0xead8;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol
          ? Symbol.for('react.fundamental')
          : 0xead5;
        var REACT_RESPONDER_TYPE = hasSymbol
          ? Symbol.for('react.responder')
          : 0xead6;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

        function isValidElementType(type) {
          return (
            typeof type === 'string' ||
            typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE ||
            type === REACT_CONCURRENT_MODE_TYPE ||
            type === REACT_PROFILER_TYPE ||
            type === REACT_STRICT_MODE_TYPE ||
            type === REACT_SUSPENSE_TYPE ||
            type === REACT_SUSPENSE_LIST_TYPE ||
            (typeof type === 'object' &&
              type !== null &&
              (type.$$typeof === REACT_LAZY_TYPE ||
                type.$$typeof === REACT_MEMO_TYPE ||
                type.$$typeof === REACT_PROVIDER_TYPE ||
                type.$$typeof === REACT_CONTEXT_TYPE ||
                type.$$typeof === REACT_FORWARD_REF_TYPE ||
                type.$$typeof === REACT_FUNDAMENTAL_TYPE ||
                type.$$typeof === REACT_RESPONDER_TYPE ||
                type.$$typeof === REACT_SCOPE_TYPE ||
                type.$$typeof === REACT_BLOCK_TYPE))
          );
        }

        function typeOf(object) {
          if (typeof object === 'object' && object !== null) {
            var $$typeof = object.$$typeof;

            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;

                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;

                  default:
                    var $$typeofType = type && type.$$typeof;

                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;

                      default:
                        return $$typeof;
                    }
                }

              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }

          return undefined;
        } // AsyncMode is deprecated along with isAsyncMode

        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

              console['warn'](
                'The ReactIs.isAsyncMode() alias has been deprecated, ' +
                  'and will be removed in React 17+. Update your code to use ' +
                  'ReactIs.isConcurrentMode() instead. It has the exact same API.',
              );
            }
          }

          return (
            isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE
          );
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return (
            typeof object === 'object' &&
            object !== null &&
            object.$$typeof === REACT_ELEMENT_TYPE
          );
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }

        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  });
  var reactIs_development_1 = reactIs_development.AsyncMode;
  var reactIs_development_2 = reactIs_development.ConcurrentMode;
  var reactIs_development_3 = reactIs_development.ContextConsumer;
  var reactIs_development_4 = reactIs_development.ContextProvider;
  var reactIs_development_5 = reactIs_development.Element;
  var reactIs_development_6 = reactIs_development.ForwardRef;
  var reactIs_development_7 = reactIs_development.Fragment;
  var reactIs_development_8 = reactIs_development.Lazy;
  var reactIs_development_9 = reactIs_development.Memo;
  var reactIs_development_10 = reactIs_development.Portal;
  var reactIs_development_11 = reactIs_development.Profiler;
  var reactIs_development_12 = reactIs_development.StrictMode;
  var reactIs_development_13 = reactIs_development.Suspense;
  var reactIs_development_14 = reactIs_development.isAsyncMode;
  var reactIs_development_15 = reactIs_development.isConcurrentMode;
  var reactIs_development_16 = reactIs_development.isContextConsumer;
  var reactIs_development_17 = reactIs_development.isContextProvider;
  var reactIs_development_18 = reactIs_development.isElement;
  var reactIs_development_19 = reactIs_development.isForwardRef;
  var reactIs_development_20 = reactIs_development.isFragment;
  var reactIs_development_21 = reactIs_development.isLazy;
  var reactIs_development_22 = reactIs_development.isMemo;
  var reactIs_development_23 = reactIs_development.isPortal;
  var reactIs_development_24 = reactIs_development.isProfiler;
  var reactIs_development_25 = reactIs_development.isStrictMode;
  var reactIs_development_26 = reactIs_development.isSuspense;
  var reactIs_development_27 = reactIs_development.isValidElementType;
  var reactIs_development_28 = reactIs_development.typeOf;

  var reactIs = createCommonjsModule(function(module) {
    {
      module.exports = reactIs_development;
    }
  });

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError(
        'Object.assign cannot be called with null or undefined',
      );
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }

      // Detect buggy property enumeration order in older V8 versions.

      // https://bugs.chromium.org/p/v8/issues/detail?id=4118
      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
      test1[5] = 'de';
      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test2 = {};
      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }
      var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
        return test2[n];
      });
      if (order2.join('') !== '0123456789') {
        return false;
      }

      // https://bugs.chromium.org/p/v8/issues/detail?id=3056
      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
        test3[letter] = letter;
      });
      if (
        Object.keys(Object.assign({}, test3)).join('') !==
        'abcdefghijklmnopqrst'
      ) {
        return false;
      }

      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }

  var objectAssign = shouldUseNative()
    ? Object.assign
    : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;

        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);

          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }

          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }

        return to;
      };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

  var ReactPropTypesSecret_1 = ReactPropTypesSecret;

  var printWarning = function() {};

  {
    var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
    var loggedTypeFailures = {};
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    printWarning = function(text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  /**
   * Assert that the values match with the type specs.
   * Error messages are memorized and will only be shown once.
   *
   * @param {object} typeSpecs Map of name to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @param {string} componentName Name of the component for error messages.
   * @param {?Function} getStack Returns the component stack.
   * @private
   */
  function checkPropTypes(
    typeSpecs,
    values,
    location,
    componentName,
    getStack,
  ) {
    {
      for (var typeSpecName in typeSpecs) {
        if (has(typeSpecs, typeSpecName)) {
          var error;
          // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.
          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              var err = Error(
                (componentName || 'React class') +
                  ': ' +
                  location +
                  ' type `' +
                  typeSpecName +
                  '` is invalid; ' +
                  'it must be a function, usually from the `prop-types` package, but received `' +
                  typeof typeSpecs[typeSpecName] +
                  '`.',
              );
              err.name = 'Invariant Violation';
              throw err;
            }
            error = typeSpecs[typeSpecName](
              values,
              typeSpecName,
              componentName,
              location,
              null,
              ReactPropTypesSecret$1,
            );
          } catch (ex) {
            error = ex;
          }
          if (error && !(error instanceof Error)) {
            printWarning(
              (componentName || 'React class') +
                ': type specification of ' +
                location +
                ' `' +
                typeSpecName +
                '` is invalid; the type checker ' +
                'function must return `null` or an `Error` but returned a ' +
                typeof error +
                '. ' +
                'You may have forgotten to pass an argument to the type checker ' +
                'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
                'shape all require an argument).',
            );
          }
          if (
            error instanceof Error &&
            !(error.message in loggedTypeFailures)
          ) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error.message] = true;

            var stack = getStack ? getStack() : '';

            printWarning(
              'Failed ' +
                location +
                ' type: ' +
                error.message +
                (stack != null ? stack : ''),
            );
          }
        }
      }
    }
  }

  /**
   * Resets warning cache when testing.
   *
   * @private
   */
  checkPropTypes.resetWarningCache = function() {
    {
      loggedTypeFailures = {};
    }
  };

  var checkPropTypes_1 = checkPropTypes;

  var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
  var printWarning$1 = function() {};

  {
    printWarning$1 = function(text) {
      var message = 'Warning: ' + text;
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };
  }

  function emptyFunctionThatReturnsNull() {
    return null;
  }

  var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */
    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

    /**
     * Returns the iterator method function contained on the iterable object.
     *
     * Be sure to invoke the function with the iterable as context:
     *
     *     var iteratorFn = getIteratorFn(myIterable);
     *     if (iteratorFn) {
     *       var iterator = iteratorFn.call(myIterable);
     *       ...
     *     }
     *
     * @param {?object} maybeIterable
     * @return {?function}
     */
    function getIteratorFn(maybeIterable) {
      var iteratorFn =
        maybeIterable &&
        ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
          maybeIterable[FAUX_ITERATOR_SYMBOL]);
      if (typeof iteratorFn === 'function') {
        return iteratorFn;
      }
    }

    /**
     * Collection of methods that allow declaration and validation of props that are
     * supplied to React components. Example usage:
     *
     *   var Props = require('ReactPropTypes');
     *   var MyArticle = React.createClass({
     *     propTypes: {
     *       // An optional string prop named "description".
     *       description: Props.string,
     *
     *       // A required enum prop named "category".
     *       category: Props.oneOf(['News','Photos']).isRequired,
     *
     *       // A prop named "dialog" that requires an instance of Dialog.
     *       dialog: Props.instanceOf(Dialog).isRequired
     *     },
     *     render: function() { ... }
     *   });
     *
     * A more formal specification of how these methods are used:
     *
     *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
     *   decl := ReactPropTypes.{type}(.isRequired)?
     *
     * Each and every declaration produces a function with the same signature. This
     * allows the creation of custom validation functions. For example:
     *
     *  var MyLink = React.createClass({
     *    propTypes: {
     *      // An optional string or URI prop named "href".
     *      href: function(props, propName, componentName) {
     *        var propValue = props[propName];
     *        if (propValue != null && typeof propValue !== 'string' &&
     *            !(propValue instanceof URI)) {
     *          return new Error(
     *            'Expected a string or an URI for ' + propName + ' in ' +
     *            componentName
     *          );
     *        }
     *      }
     *    },
     *    render: function() {...}
     *  });
     *
     * @internal
     */

    var ANONYMOUS = '<<anonymous>>';

    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
      array: createPrimitiveTypeChecker('array'),
      bool: createPrimitiveTypeChecker('boolean'),
      func: createPrimitiveTypeChecker('function'),
      number: createPrimitiveTypeChecker('number'),
      object: createPrimitiveTypeChecker('object'),
      string: createPrimitiveTypeChecker('string'),
      symbol: createPrimitiveTypeChecker('symbol'),

      any: createAnyTypeChecker(),
      arrayOf: createArrayOfTypeChecker,
      element: createElementTypeChecker(),
      elementType: createElementTypeTypeChecker(),
      instanceOf: createInstanceTypeChecker,
      node: createNodeChecker(),
      objectOf: createObjectOfTypeChecker,
      oneOf: createEnumTypeChecker,
      oneOfType: createUnionTypeChecker,
      shape: createShapeTypeChecker,
      exact: createStrictShapeTypeChecker,
    };

    /**
     * inlined Object.is polyfill to avoid requiring consumers ship their own
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
     */
    /*eslint-disable no-self-compare*/
    function is(x, y) {
      // SameValue algorithm
      if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
      } else {
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
      }
    }
    /*eslint-enable no-self-compare*/

    /**
     * We use an Error-like object for backward compatibility as people may call
     * PropTypes directly and inspect their output. However, we don't use real
     * Errors anymore. We don't inspect their stack anyway, and creating them
     * is prohibitively expensive if they are created too often, such as what
     * happens in oneOfType() for any type before the one that matched.
     */
    function PropTypeError(message) {
      this.message = message;
      this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;

    function createChainableTypeChecker(validate) {
      {
        var manualPropTypeCallCache = {};
        var manualPropTypeWarningCount = 0;
      }
      function checkType(
        isRequired,
        props,
        propName,
        componentName,
        location,
        propFullName,
        secret,
      ) {
        componentName = componentName || ANONYMOUS;
        propFullName = propFullName || propName;

        if (secret !== ReactPropTypesSecret_1) {
          if (throwOnDirectAccess) {
            // New behavior only for users of `prop-types` package
            var err = new Error(
              'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
                'Use `PropTypes.checkPropTypes()` to call them. ' +
                'Read more at http://fb.me/use-check-prop-types',
            );
            err.name = 'Invariant Violation';
            throw err;
          } else if (typeof console !== 'undefined') {
            // Old behavior for people using React.PropTypes
            var cacheKey = componentName + ':' + propName;
            if (
              !manualPropTypeCallCache[cacheKey] &&
              // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3
            ) {
              printWarning$1(
                'You are manually calling a React.PropTypes validation ' +
                  'function for the `' +
                  propFullName +
                  '` prop on `' +
                  componentName +
                  '`. This is deprecated ' +
                  'and will throw in the standalone `prop-types` package. ' +
                  'You may be seeing this warning due to a third-party PropTypes ' +
                  'library. See https://fb.me/react-warning-dont-call-proptypes ' +
                  'for details.',
              );
              manualPropTypeCallCache[cacheKey] = true;
              manualPropTypeWarningCount++;
            }
          }
        }
        if (props[propName] == null) {
          if (isRequired) {
            if (props[propName] === null) {
              return new PropTypeError(
                'The ' +
                  location +
                  ' `' +
                  propFullName +
                  '` is marked as required ' +
                  ('in `' + componentName + '`, but its value is `null`.'),
              );
            }
            return new PropTypeError(
              'The ' +
                location +
                ' `' +
                propFullName +
                '` is marked as required in ' +
                ('`' + componentName + '`, but its value is `undefined`.'),
            );
          }
          return null;
        } else {
          return validate(
            props,
            propName,
            componentName,
            location,
            propFullName,
          );
        }
      }

      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);

      return chainedCheckType;
    }

    function createPrimitiveTypeChecker(expectedType) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
        secret,
      ) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== expectedType) {
          // `propValue` being instance of, say, date/regexp, pass the 'object'
          // check, but we can offer a more precise error message here rather than
          // 'of type `object`'.
          var preciseType = getPreciseType(propValue);

          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                preciseType +
                '` supplied to `' +
                componentName +
                '`, expected ') +
              ('`' + expectedType + '`.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createAnyTypeChecker() {
      return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }

    function createArrayOfTypeChecker(typeChecker) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError(
            'Property `' +
              propFullName +
              '` of component `' +
              componentName +
              '` has invalid PropType notation inside arrayOf.',
          );
        }
        var propValue = props[propName];
        if (!Array.isArray(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                propType +
                '` supplied to `' +
                componentName +
                '`, expected an array.'),
          );
        }
        for (var i = 0; i < propValue.length; i++) {
          var error = typeChecker(
            propValue,
            i,
            componentName,
            location,
            propFullName + '[' + i + ']',
            ReactPropTypesSecret_1,
          );
          if (error instanceof Error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createElementTypeChecker() {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        if (!isValidElement(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                propType +
                '` supplied to `' +
                componentName +
                '`, expected a single ReactElement.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createElementTypeTypeChecker() {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        if (!reactIs.isValidElementType(propValue)) {
          var propType = getPropType(propValue);
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                propType +
                '` supplied to `' +
                componentName +
                '`, expected a single ReactElement type.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createInstanceTypeChecker(expectedClass) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (!(props[propName] instanceof expectedClass)) {
          var expectedClassName = expectedClass.name || ANONYMOUS;
          var actualClassName = getClassName(props[propName]);
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                actualClassName +
                '` supplied to `' +
                componentName +
                '`, expected ') +
              ('instance of `' + expectedClassName + '`.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createEnumTypeChecker(expectedValues) {
      if (!Array.isArray(expectedValues)) {
        {
          if (arguments.length > 1) {
            printWarning$1(
              'Invalid arguments supplied to oneOf, expected an array, got ' +
                arguments.length +
                ' arguments. ' +
                'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).',
            );
          } else {
            printWarning$1(
              'Invalid argument supplied to oneOf, expected an array.',
            );
          }
        }
        return emptyFunctionThatReturnsNull;
      }

      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        for (var i = 0; i < expectedValues.length; i++) {
          if (is(propValue, expectedValues[i])) {
            return null;
          }
        }

        var valuesString = JSON.stringify(expectedValues, function replacer(
          key,
          value,
        ) {
          var type = getPreciseType(value);
          if (type === 'symbol') {
            return String(value);
          }
          return value;
        });
        return new PropTypeError(
          'Invalid ' +
            location +
            ' `' +
            propFullName +
            '` of value `' +
            String(propValue) +
            '` ' +
            ('supplied to `' +
              componentName +
              '`, expected one of ' +
              valuesString +
              '.'),
        );
      }
      return createChainableTypeChecker(validate);
    }

    function createObjectOfTypeChecker(typeChecker) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (typeof typeChecker !== 'function') {
          return new PropTypeError(
            'Property `' +
              propFullName +
              '` of component `' +
              componentName +
              '` has invalid PropType notation inside objectOf.',
          );
        }
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type ' +
              ('`' +
                propType +
                '` supplied to `' +
                componentName +
                '`, expected an object.'),
          );
        }
        for (var key in propValue) {
          if (has$1(propValue, key)) {
            var error = typeChecker(
              propValue,
              key,
              componentName,
              location,
              propFullName + '.' + key,
              ReactPropTypesSecret_1,
            );
            if (error instanceof Error) {
              return error;
            }
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createUnionTypeChecker(arrayOfTypeCheckers) {
      if (!Array.isArray(arrayOfTypeCheckers)) {
        printWarning$1(
          'Invalid argument supplied to oneOfType, expected an instance of array.',
        );
        return emptyFunctionThatReturnsNull;
      }

      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (typeof checker !== 'function') {
          printWarning$1(
            'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
              'received ' +
              getPostfixForTypeWarning(checker) +
              ' at index ' +
              i +
              '.',
          );
          return emptyFunctionThatReturnsNull;
        }
      }

      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (
            checker(
              props,
              propName,
              componentName,
              location,
              propFullName,
              ReactPropTypesSecret_1,
            ) == null
          ) {
            return null;
          }
        }

        return new PropTypeError(
          'Invalid ' +
            location +
            ' `' +
            propFullName +
            '` supplied to ' +
            ('`' + componentName + '`.'),
        );
      }
      return createChainableTypeChecker(validate);
    }

    function createNodeChecker() {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        if (!isNode(props[propName])) {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` supplied to ' +
              ('`' + componentName + '`, expected a ReactNode.'),
          );
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createShapeTypeChecker(shapeTypes) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type `' +
              propType +
              '` ' +
              ('supplied to `' + componentName + '`, expected `object`.'),
          );
        }
        for (var key in shapeTypes) {
          var checker = shapeTypes[key];
          if (!checker) {
            continue;
          }
          var error = checker(
            propValue,
            key,
            componentName,
            location,
            propFullName + '.' + key,
            ReactPropTypesSecret_1,
          );
          if (error) {
            return error;
          }
        }
        return null;
      }
      return createChainableTypeChecker(validate);
    }

    function createStrictShapeTypeChecker(shapeTypes) {
      function validate(
        props,
        propName,
        componentName,
        location,
        propFullName,
      ) {
        var propValue = props[propName];
        var propType = getPropType(propValue);
        if (propType !== 'object') {
          return new PropTypeError(
            'Invalid ' +
              location +
              ' `' +
              propFullName +
              '` of type `' +
              propType +
              '` ' +
              ('supplied to `' + componentName + '`, expected `object`.'),
          );
        }
        // We need to check all keys in case some are required but missing from
        // props.
        var allKeys = objectAssign({}, props[propName], shapeTypes);
        for (var key in allKeys) {
          var checker = shapeTypes[key];
          if (!checker) {
            return new PropTypeError(
              'Invalid ' +
                location +
                ' `' +
                propFullName +
                '` key `' +
                key +
                '` supplied to `' +
                componentName +
                '`.' +
                '\nBad object: ' +
                JSON.stringify(props[propName], null, '  ') +
                '\nValid keys: ' +
                JSON.stringify(Object.keys(shapeTypes), null, '  '),
            );
          }
          var error = checker(
            propValue,
            key,
            componentName,
            location,
            propFullName + '.' + key,
            ReactPropTypesSecret_1,
          );
          if (error) {
            return error;
          }
        }
        return null;
      }

      return createChainableTypeChecker(validate);
    }

    function isNode(propValue) {
      switch (typeof propValue) {
        case 'number':
        case 'string':
        case 'undefined':
          return true;
        case 'boolean':
          return !propValue;
        case 'object':
          if (Array.isArray(propValue)) {
            return propValue.every(isNode);
          }
          if (propValue === null || isValidElement(propValue)) {
            return true;
          }

          var iteratorFn = getIteratorFn(propValue);
          if (iteratorFn) {
            var iterator = iteratorFn.call(propValue);
            var step;
            if (iteratorFn !== propValue.entries) {
              while (!(step = iterator.next()).done) {
                if (!isNode(step.value)) {
                  return false;
                }
              }
            } else {
              // Iterator will provide entry [k,v] tuples rather than values.
              while (!(step = iterator.next()).done) {
                var entry = step.value;
                if (entry) {
                  if (!isNode(entry[1])) {
                    return false;
                  }
                }
              }
            }
          } else {
            return false;
          }

          return true;
        default:
          return false;
      }
    }

    function isSymbol(propType, propValue) {
      // Native Symbol.
      if (propType === 'symbol') {
        return true;
      }

      // falsy value can't be a Symbol
      if (!propValue) {
        return false;
      }

      // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
      if (propValue['@@toStringTag'] === 'Symbol') {
        return true;
      }

      // Fallback for non-spec compliant Symbols which are polyfilled.
      if (typeof Symbol === 'function' && propValue instanceof Symbol) {
        return true;
      }

      return false;
    }

    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return 'array';
      }
      if (propValue instanceof RegExp) {
        // Old webkits (at least until Android 4.0) return 'function' rather than
        // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
        // passes PropTypes.object.
        return 'object';
      }
      if (isSymbol(propType, propValue)) {
        return 'symbol';
      }
      return propType;
    }

    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
      if (typeof propValue === 'undefined' || propValue === null) {
        return '' + propValue;
      }
      var propType = getPropType(propValue);
      if (propType === 'object') {
        if (propValue instanceof Date) {
          return 'date';
        } else if (propValue instanceof RegExp) {
          return 'regexp';
        }
      }
      return propType;
    }

    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
      var type = getPreciseType(value);
      switch (type) {
        case 'array':
        case 'object':
          return 'an ' + type;
        case 'boolean':
        case 'date':
        case 'regexp':
          return 'a ' + type;
        default:
          return type;
      }
    }

    // Returns class name of the object, if any.
    function getClassName(propValue) {
      if (!propValue.constructor || !propValue.constructor.name) {
        return ANONYMOUS;
      }
      return propValue.constructor.name;
    }

    ReactPropTypes.checkPropTypes = checkPropTypes_1;
    ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;

    return ReactPropTypes;
  };

  var propTypes = createCommonjsModule(function(module) {
    /**
     * Copyright (c) 2013-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    {
      var ReactIs = reactIs;

      // By explicitly using `prop-types` you are opting into new development behavior.
      // http://fb.me/prop-types-in-prod
      var throwOnDirectAccess = true;
      module.exports = factoryWithTypeCheckers(
        ReactIs.isElement,
        throwOnDirectAccess,
      );
    }
  });

  var msPerFrame = 1000 / 60;

  var Motion = /*#__PURE__*/ (function(_React$Component) {
    _inheritsLoose(Motion, _React$Component);

    function Motion(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.unmounting = false;
      _this.wasAnimating = false;
      _this.animationID = null;
      _this.prevTime = 0;
      _this.accumulatedTime = 0;
      _this.unreadPropStyle = null;

      _this.clearUnreadPropStyle = function(destStyle) {
        var dirty = false;
        var _this$state = _this.state,
          currentStyle = _this$state.currentStyle,
          currentVelocity = _this$state.currentVelocity,
          lastIdealStyle = _this$state.lastIdealStyle,
          lastIdealVelocity = _this$state.lastIdealVelocity;

        for (var key in destStyle) {
          if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
            continue;
          }

          var styleValue = destStyle[key];

          if (typeof styleValue === 'number') {
            if (!dirty) {
              dirty = true;
              currentStyle = _extends({}, currentStyle);
              currentVelocity = _extends({}, currentVelocity);
              lastIdealStyle = _extends({}, lastIdealStyle);
              lastIdealVelocity = _extends({}, lastIdealVelocity);
            }

            currentStyle[key] = styleValue;
            currentVelocity[key] = 0;
            lastIdealStyle[key] = styleValue;
            lastIdealVelocity[key] = 0;
          }
        }

        if (dirty) {
          _this.setState({
            currentStyle: currentStyle,
            currentVelocity: currentVelocity,
            lastIdealStyle: lastIdealStyle,
            lastIdealVelocity: lastIdealVelocity,
          });
        }
      };

      _this.startAnimationIfNecessary = function() {
        if (_this.unmounting || _this.animationID != null) {
          return;
        } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
        // call cb? No, otherwise accidental parent rerender causes cb trigger

        _this.animationID = raf_1(function(timestamp) {
          // https://github.com/chenglou/react-motion/pull/420
          // > if execution passes the conditional if (this.unmounting), then
          // executes async defaultRaf and after that component unmounts and after
          // that the callback of defaultRaf is called, then setState will be called
          // on unmounted component.
          if (_this.unmounting) {
            return;
          } // check if we need to animate in the first place

          var propsStyle = _this.props.style;

          if (
            shouldStopAnimation(
              _this.state.currentStyle,
              propsStyle,
              _this.state.currentVelocity,
            )
          ) {
            if (_this.wasAnimating && _this.props.onRest) {
              _this.props.onRest();
            } // no need to cancel animationID here; shouldn't have any in flight

            _this.animationID = null;
            _this.wasAnimating = false;
            _this.accumulatedTime = 0;
            return;
          }

          _this.wasAnimating = true;
          var currentTime = timestamp || performanceNow();
          var timeDelta = currentTime - _this.prevTime;
          _this.prevTime = currentTime;
          _this.accumulatedTime = _this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart

          if (_this.accumulatedTime > msPerFrame * 10) {
            _this.accumulatedTime = 0;
          }

          if (_this.accumulatedTime === 0) {
            // no need to cancel animationID here; shouldn't have any in flight
            _this.animationID = null;

            _this.startAnimationIfNecessary();

            return;
          }

          var currentFrameCompletion =
            (_this.accumulatedTime -
              Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) /
            msPerFrame;
          var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);
          var newLastIdealStyle = {};
          var newLastIdealVelocity = {};
          var newCurrentStyle = {};
          var newCurrentVelocity = {};

          for (var key in propsStyle) {
            if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {
              continue;
            }

            var styleValue = propsStyle[key];

            if (typeof styleValue === 'number') {
              newCurrentStyle[key] = styleValue;
              newCurrentVelocity[key] = 0;
              newLastIdealStyle[key] = styleValue;
              newLastIdealVelocity[key] = 0;
            } else {
              var newLastIdealStyleValue = _this.state.lastIdealStyle[key];
              var newLastIdealVelocityValue =
                _this.state.lastIdealVelocity[key];

              for (var i = 0; i < framesToCatchUp; i++) {
                var _stepper = stepper(
                  msPerFrame / 1000,
                  newLastIdealStyleValue,
                  newLastIdealVelocityValue,
                  styleValue.val,
                  styleValue.stiffness,
                  styleValue.damping,
                  styleValue.precision,
                );

                newLastIdealStyleValue = _stepper[0];
                newLastIdealVelocityValue = _stepper[1];
              }

              var _stepper2 = stepper(
                  msPerFrame / 1000,
                  newLastIdealStyleValue,
                  newLastIdealVelocityValue,
                  styleValue.val,
                  styleValue.stiffness,
                  styleValue.damping,
                  styleValue.precision,
                ),
                nextIdealX = _stepper2[0],
                nextIdealV = _stepper2[1];

              newCurrentStyle[key] =
                newLastIdealStyleValue +
                (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;
              newCurrentVelocity[key] =
                newLastIdealVelocityValue +
                (nextIdealV - newLastIdealVelocityValue) *
                  currentFrameCompletion;
              newLastIdealStyle[key] = newLastIdealStyleValue;
              newLastIdealVelocity[key] = newLastIdealVelocityValue;
            }
          }

          _this.animationID = null; // the amount we're looped over above

          _this.accumulatedTime -= framesToCatchUp * msPerFrame;

          _this.setState({
            currentStyle: newCurrentStyle,
            currentVelocity: newCurrentVelocity,
            lastIdealStyle: newLastIdealStyle,
            lastIdealVelocity: newLastIdealVelocity,
          });

          _this.unreadPropStyle = null;

          _this.startAnimationIfNecessary();
        });
      };

      _this.state = _this.defaultState();
      return _this;
    }

    var _proto = Motion.prototype;

    _proto.defaultState = function defaultState() {
      var _this$props = this.props,
        defaultStyle = _this$props.defaultStyle,
        style = _this$props.style;
      var currentStyle = defaultStyle || stripStyle(style);
      var currentVelocity = mapToZero(currentStyle);
      return {
        currentStyle: currentStyle,
        currentVelocity: currentVelocity,
        lastIdealStyle: currentStyle,
        lastIdealVelocity: currentVelocity,
      };
    }; // it's possible that currentStyle's value is stale: if props is immediately
    // changed from 0 to 400 to spring(0) again, the async currentStyle is still
    // at 0 (didn't have time to tick and interpolate even once). If we naively
    // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
    // In reality currentStyle should be 400

    _proto.componentDidMount = function componentDidMount() {
      this.prevTime = performanceNow();
      this.startAnimationIfNecessary();
    };

    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(
      props,
    ) {
      if (this.unreadPropStyle != null) {
        // previous props haven't had the chance to be set yet; set them here
        this.clearUnreadPropStyle(this.unreadPropStyle);
      }

      this.unreadPropStyle = props.style;

      if (this.animationID == null) {
        this.prevTime = performanceNow();
        this.startAnimationIfNecessary();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.unmounting = true;

      if (this.animationID != null) {
        raf_1.cancel(this.animationID);
        this.animationID = null;
      }
    };

    _proto.render = function render() {
      var renderedChildren = this.props.children(this.state.currentStyle);
      return renderedChildren && React.Children.only(renderedChildren);
    };

    return Motion;
  })(React.Component);
  Motion.propTypes = {
    // TOOD: warn against putting a config in here
    defaultStyle: propTypes.objectOf(propTypes.number),
    style: propTypes.objectOf(
      propTypes.oneOfType([propTypes.number, propTypes.object]),
    ).isRequired,
    children: propTypes.func.isRequired,
    onRest: propTypes.func,
  };

  var msPerFrame$1 = 1000 / 60;

  function shouldStopAnimationAll(currentStyles, styles, currentVelocities) {
    for (var i = 0; i < currentStyles.length; i++) {
      if (
        !shouldStopAnimation(currentStyles[i], styles[i], currentVelocities[i])
      ) {
        return false;
      }
    }

    return true;
  }

  var StaggeredMotion = /*#__PURE__*/ (function(_React$Component) {
    _inheritsLoose(StaggeredMotion, _React$Component);

    function StaggeredMotion(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.unmounting = false;
      _this.animationID = null;
      _this.prevTime = 0;
      _this.accumulatedTime = 0;
      _this.unreadPropStyles = null;

      _this.clearUnreadPropStyle = function(unreadPropStyles) {
        var _this$state = _this.state,
          currentStyles = _this$state.currentStyles,
          currentVelocities = _this$state.currentVelocities,
          lastIdealStyles = _this$state.lastIdealStyles,
          lastIdealVelocities = _this$state.lastIdealVelocities;
        var someDirty = false;

        for (var i = 0; i < unreadPropStyles.length; i++) {
          var unreadPropStyle = unreadPropStyles[i];
          var dirty = false;

          for (var key in unreadPropStyle) {
            if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
              continue;
            }

            var styleValue = unreadPropStyle[key];

            if (typeof styleValue === 'number') {
              if (!dirty) {
                dirty = true;
                someDirty = true;
                currentStyles[i] = _extends({}, currentStyles[i]);
                currentVelocities[i] = _extends({}, currentVelocities[i]);
                lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
                lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
              }

              currentStyles[i][key] = styleValue;
              currentVelocities[i][key] = 0;
              lastIdealStyles[i][key] = styleValue;
              lastIdealVelocities[i][key] = 0;
            }
          }
        }

        if (someDirty) {
          _this.setState({
            currentStyles: currentStyles,
            currentVelocities: currentVelocities,
            lastIdealStyles: lastIdealStyles,
            lastIdealVelocities: lastIdealVelocities,
          });
        }
      };

      _this.startAnimationIfNecessary = function() {
        if (_this.unmounting || _this.animationID != null) {
          return;
        } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
        // call cb? No, otherwise accidental parent rerender causes cb trigger

        _this.animationID = raf_1(function(timestamp) {
          // https://github.com/chenglou/react-motion/pull/420
          // > if execution passes the conditional if (this.unmounting), then
          // executes async defaultRaf and after that component unmounts and after
          // that the callback of defaultRaf is called, then setState will be called
          // on unmounted component.
          if (_this.unmounting) {
            return;
          }

          var destStyles = _this.props.styles(_this.state.lastIdealStyles); // check if we need to animate in the first place

          if (
            shouldStopAnimationAll(
              _this.state.currentStyles,
              destStyles,
              _this.state.currentVelocities,
            )
          ) {
            // no need to cancel animationID here; shouldn't have any in flight
            _this.animationID = null;
            _this.accumulatedTime = 0;
            return;
          }

          var currentTime = timestamp || performanceNow();
          var timeDelta = currentTime - _this.prevTime;
          _this.prevTime = currentTime;
          _this.accumulatedTime = _this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart

          if (_this.accumulatedTime > msPerFrame$1 * 10) {
            _this.accumulatedTime = 0;
          }

          if (_this.accumulatedTime === 0) {
            // no need to cancel animationID here; shouldn't have any in flight
            _this.animationID = null;

            _this.startAnimationIfNecessary();

            return;
          }

          var currentFrameCompletion =
            (_this.accumulatedTime -
              Math.floor(_this.accumulatedTime / msPerFrame$1) * msPerFrame$1) /
            msPerFrame$1;
          var framesToCatchUp = Math.floor(
            _this.accumulatedTime / msPerFrame$1,
          );
          var newLastIdealStyles = [];
          var newLastIdealVelocities = [];
          var newCurrentStyles = [];
          var newCurrentVelocities = [];

          for (var i = 0; i < destStyles.length; i++) {
            var destStyle = destStyles[i];
            var newCurrentStyle = {};
            var newCurrentVelocity = {};
            var newLastIdealStyle = {};
            var newLastIdealVelocity = {};

            for (var key in destStyle) {
              if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {
                continue;
              }

              var styleValue = destStyle[key];

              if (typeof styleValue === 'number') {
                newCurrentStyle[key] = styleValue;
                newCurrentVelocity[key] = 0;
                newLastIdealStyle[key] = styleValue;
                newLastIdealVelocity[key] = 0;
              } else {
                var newLastIdealStyleValue =
                  _this.state.lastIdealStyles[i][key];
                var newLastIdealVelocityValue =
                  _this.state.lastIdealVelocities[i][key];

                for (var j = 0; j < framesToCatchUp; j++) {
                  var _stepper = stepper(
                    msPerFrame$1 / 1000,
                    newLastIdealStyleValue,
                    newLastIdealVelocityValue,
                    styleValue.val,
                    styleValue.stiffness,
                    styleValue.damping,
                    styleValue.precision,
                  );

                  newLastIdealStyleValue = _stepper[0];
                  newLastIdealVelocityValue = _stepper[1];
                }

                var _stepper2 = stepper(
                    msPerFrame$1 / 1000,
                    newLastIdealStyleValue,
                    newLastIdealVelocityValue,
                    styleValue.val,
                    styleValue.stiffness,
                    styleValue.damping,
                    styleValue.precision,
                  ),
                  nextIdealX = _stepper2[0],
                  nextIdealV = _stepper2[1];

                newCurrentStyle[key] =
                  newLastIdealStyleValue +
                  (nextIdealX - newLastIdealStyleValue) *
                    currentFrameCompletion;
                newCurrentVelocity[key] =
                  newLastIdealVelocityValue +
                  (nextIdealV - newLastIdealVelocityValue) *
                    currentFrameCompletion;
                newLastIdealStyle[key] = newLastIdealStyleValue;
                newLastIdealVelocity[key] = newLastIdealVelocityValue;
              }
            }

            newCurrentStyles[i] = newCurrentStyle;
            newCurrentVelocities[i] = newCurrentVelocity;
            newLastIdealStyles[i] = newLastIdealStyle;
            newLastIdealVelocities[i] = newLastIdealVelocity;
          }

          _this.animationID = null; // the amount we're looped over above

          _this.accumulatedTime -= framesToCatchUp * msPerFrame$1;

          _this.setState({
            currentStyles: newCurrentStyles,
            currentVelocities: newCurrentVelocities,
            lastIdealStyles: newLastIdealStyles,
            lastIdealVelocities: newLastIdealVelocities,
          });

          _this.unreadPropStyles = null;

          _this.startAnimationIfNecessary();
        });
      };

      _this.state = _this.defaultState();
      return _this;
    }

    var _proto = StaggeredMotion.prototype;

    _proto.defaultState = function defaultState() {
      var _this$props = this.props,
        defaultStyles = _this$props.defaultStyles,
        styles = _this$props.styles;
      var currentStyles = defaultStyles || styles().map(stripStyle);
      var currentVelocities = currentStyles.map(function(currentStyle) {
        return mapToZero(currentStyle);
      });
      return {
        currentStyles: currentStyles,
        currentVelocities: currentVelocities,
        lastIdealStyles: currentStyles,
        lastIdealVelocities: currentVelocities,
      };
    };

    _proto.componentDidMount = function componentDidMount() {
      this.prevTime = performanceNow();
      this.startAnimationIfNecessary();
    };

    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(
      props,
    ) {
      if (this.unreadPropStyles != null) {
        // previous props haven't had the chance to be set yet; set them here
        this.clearUnreadPropStyle(this.unreadPropStyles);
      }

      this.unreadPropStyles = props.styles(this.state.lastIdealStyles);

      if (this.animationID == null) {
        this.prevTime = performanceNow();
        this.startAnimationIfNecessary();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.unmounting = true;

      if (this.animationID != null) {
        raf_1.cancel(this.animationID);
        this.animationID = null;
      }
    };

    _proto.render = function render() {
      var renderedChildren = this.props.children(this.state.currentStyles);
      return renderedChildren && React.Children.only(renderedChildren);
    };

    return StaggeredMotion;
  })(React.Component);
  StaggeredMotion.propTypes = {
    // TOOD: warn against putting a config in here
    defaultStyles: propTypes.arrayOf(propTypes.objectOf(propTypes.number)),
    styles: propTypes.func.isRequired,
    children: propTypes.func.isRequired,
  };

  // core keys merging algorithm. If previous render's keys are [a, b], and the
  // next render's [c, b, d], what's the final merged keys and ordering?
  // - c and a must both be before b
  // - b before d
  // - ordering between a and c ambiguous
  // this reduces to merging two partially ordered lists (e.g. lists where not
  // every item has a definite ordering, like comparing a and c above). For the
  // ambiguous ordering we deterministically choose to place the next render's
  // item after the previous'; so c after a
  // this is called a topological sorting. Except the existing algorithms don't
  // work well with js bc of the amount of allocation, and isn't optimized for our
  // current use-case bc the runtime is linear in terms of edges (see wiki for
  // meaning), which is huge when two lists have many common elements
  function mergeDiff(prev, next, onRemove) {
    // bookkeeping for easier access of a key's index below. This is 2 allocations +
    // potentially triggering chrome hash map mode for objs (so it might be faster
    // to loop through and find a key's index each time), but I no longer care
    var prevKeyIndex = {};

    for (var i = 0; i < prev.length; i++) {
      prevKeyIndex[prev[i].key] = i;
    }

    var nextKeyIndex = {};

    for (var _i = 0; _i < next.length; _i++) {
      nextKeyIndex[next[_i].key] = _i;
    } // first, an overly elaborate way of merging prev and next, eliminating
    // duplicates (in terms of keys). If there's dupe, keep the item in next).
    // This way of writing it saves allocations

    var ret = [];

    for (var _i2 = 0; _i2 < next.length; _i2++) {
      ret[_i2] = next[_i2];
    }

    for (var _i3 = 0; _i3 < prev.length; _i3++) {
      if (!Object.prototype.hasOwnProperty.call(nextKeyIndex, prev[_i3].key)) {
        // this is called my TM's `mergeAndSync`, which calls willLeave. We don't
        // merge in keys that the user desires to kill
        var fill = onRemove(_i3, prev[_i3]);

        if (fill != null) {
          ret.push(fill);
        }
      }
    } // now all the items all present. Core sorting logic to have the right order

    return ret.sort(function(a, b) {
      var nextOrderA = nextKeyIndex[a.key];
      var nextOrderB = nextKeyIndex[b.key];
      var prevOrderA = prevKeyIndex[a.key];
      var prevOrderB = prevKeyIndex[b.key];

      if (nextOrderA != null && nextOrderB != null) {
        // both keys in next
        return nextKeyIndex[a.key] - nextKeyIndex[b.key];
      } else if (prevOrderA != null && prevOrderB != null) {
        // both keys in prev
        return prevKeyIndex[a.key] - prevKeyIndex[b.key];
      } else if (nextOrderA != null) {
        // key a in next, key b in prev
        // how to determine the order between a and b? We find a "pivot" (term
        // abuse), a key present in both prev and next, that is sandwiched between
        // a and b. In the context of our above example, if we're comparing a and
        // d, b's (the only) pivot
        for (var _i4 = 0; _i4 < next.length; _i4++) {
          var pivot = next[_i4].key;

          if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, pivot)) {
            continue;
          }

          if (
            nextOrderA < nextKeyIndex[pivot] &&
            prevOrderB > prevKeyIndex[pivot]
          ) {
            return -1;
          } else if (
            nextOrderA > nextKeyIndex[pivot] &&
            prevOrderB < prevKeyIndex[pivot]
          ) {
            return 1;
          }
        } // pluggable. default to: next bigger than prev

        return 1;
      } // prevOrderA, nextOrderB

      for (var _i5 = 0; _i5 < next.length; _i5++) {
        var _pivot = next[_i5].key;

        if (!Object.prototype.hasOwnProperty.call(prevKeyIndex, _pivot)) {
          continue;
        }

        if (
          nextOrderB < nextKeyIndex[_pivot] &&
          prevOrderA > prevKeyIndex[_pivot]
        ) {
          return 1;
        } else if (
          nextOrderB > nextKeyIndex[_pivot] &&
          prevOrderA < prevKeyIndex[_pivot]
        ) {
          return -1;
        }
      } // pluggable. default to: next bigger than prev

      return -1;
    });
  }

  var msPerFrame$2 = 1000 / 60; // the children function & (potential) styles function asks as param an
  // Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format
  // {key: string, data?: any, style: PlainStyle}. However, the way we keep
  // internal states doesn't contain such a data structure (check the state and
  // TransitionMotionState). So when children function and others ask for such
  // data we need to generate them on the fly by combining mergedPropsStyles and
  // currentStyles/lastIdealStyles

  function rehydrateStyles(mergedPropsStyles, unreadPropStyles, plainStyles) {
    // Copy the value to a `const` so that Flow understands that the const won't
    // change and will be non-nullable in the callback below.
    var cUnreadPropStyles = unreadPropStyles;

    if (cUnreadPropStyles == null) {
      return mergedPropsStyles.map(function(mergedPropsStyle, i) {
        return {
          key: mergedPropsStyle.key,
          data: mergedPropsStyle.data,
          style: plainStyles[i],
        };
      });
    }

    return mergedPropsStyles.map(function(mergedPropsStyle, i) {
      for (var j = 0; j < cUnreadPropStyles.length; j++) {
        if (cUnreadPropStyles[j].key === mergedPropsStyle.key) {
          return {
            key: cUnreadPropStyles[j].key,
            data: cUnreadPropStyles[j].data,
            style: plainStyles[i],
          };
        }
      }

      return {
        key: mergedPropsStyle.key,
        data: mergedPropsStyle.data,
        style: plainStyles[i],
      };
    });
  }

  function shouldStopAnimationAll$1(
    currentStyles,
    destStyles,
    currentVelocities,
    mergedPropsStyles,
  ) {
    if (mergedPropsStyles.length !== destStyles.length) {
      return false;
    }

    for (var i = 0; i < mergedPropsStyles.length; i++) {
      if (mergedPropsStyles[i].key !== destStyles[i].key) {
        return false;
      }
    } // we have the invariant that mergedPropsStyles and
    // currentStyles/currentVelocities/last* are synced in terms of cells, see
    // mergeAndSync comment for more info

    for (var _i = 0; _i < mergedPropsStyles.length; _i++) {
      if (
        !shouldStopAnimation(
          currentStyles[_i],
          destStyles[_i].style,
          currentVelocities[_i],
        )
      ) {
        return false;
      }
    }

    return true;
  } // core key merging logic
  // things to do: say previously merged style is {a, b}, dest style (prop) is {b,
  // c}, previous current (interpolating) style is {a, b}
  // **invariant**: current[i] corresponds to merged[i] in terms of key
  // steps:
  // turn merged style into {a?, b, c}
  //    add c, value of c is destStyles.c
  //    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}
  // turn current (interpolating) style from {a, b} into {a?, b, c}
  //    maybe remove a
  //    certainly add c, value of c is willEnter(c)
  // loop over merged and construct new current
  // dest doesn't change, that's owner's

  function mergeAndSync(
    willEnter,
    willLeave,
    didLeave,
    oldMergedPropsStyles,
    destStyles,
    oldCurrentStyles,
    oldCurrentVelocities,
    oldLastIdealStyles,
    oldLastIdealVelocities,
  ) {
    var newMergedPropsStyles = mergeDiff(
      oldMergedPropsStyles,
      destStyles,
      function(oldIndex, oldMergedPropsStyle) {
        var leavingStyle = willLeave(oldMergedPropsStyle);

        if (leavingStyle == null) {
          didLeave({
            key: oldMergedPropsStyle.key,
            data: oldMergedPropsStyle.data,
          });
          return null;
        }

        if (
          shouldStopAnimation(
            oldCurrentStyles[oldIndex],
            leavingStyle,
            oldCurrentVelocities[oldIndex],
          )
        ) {
          didLeave({
            key: oldMergedPropsStyle.key,
            data: oldMergedPropsStyle.data,
          });
          return null;
        }

        return {
          key: oldMergedPropsStyle.key,
          data: oldMergedPropsStyle.data,
          style: leavingStyle,
        };
      },
    );
    var newCurrentStyles = [];
    var newCurrentVelocities = [];
    var newLastIdealStyles = [];
    var newLastIdealVelocities = [];

    for (var i = 0; i < newMergedPropsStyles.length; i++) {
      var newMergedPropsStyleCell = newMergedPropsStyles[i];
      var foundOldIndex = null;

      for (var j = 0; j < oldMergedPropsStyles.length; j++) {
        if (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {
          foundOldIndex = j;
          break;
        }
      } // TODO: key search code

      if (foundOldIndex == null) {
        var plainStyle = willEnter(newMergedPropsStyleCell);
        newCurrentStyles[i] = plainStyle;
        newLastIdealStyles[i] = plainStyle;
        var velocity = mapToZero(newMergedPropsStyleCell.style);
        newCurrentVelocities[i] = velocity;
        newLastIdealVelocities[i] = velocity;
      } else {
        newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];
        newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];
        newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];
        newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];
      }
    }

    return [
      newMergedPropsStyles,
      newCurrentStyles,
      newCurrentVelocities,
      newLastIdealStyles,
      newLastIdealVelocities,
    ];
  }

  var TransitionMotion = /*#__PURE__*/ (function(_React$Component) {
    _inheritsLoose(TransitionMotion, _React$Component);

    // it's possible that currentStyle's value is stale: if props is immediately
    // changed from 0 to 400 to spring(0) again, the async currentStyle is still
    // at 0 (didn't have time to tick and interpolate even once). If we naively
    // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).
    // In reality currentStyle should be 400
    function TransitionMotion(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;
      _this.unmounting = false;
      _this.animationID = null;
      _this.prevTime = 0;
      _this.accumulatedTime = 0;
      _this.unreadPropStyles = null;

      _this.clearUnreadPropStyle = function(unreadPropStyles) {
        var _mergeAndSync = mergeAndSync(
            _this.props.willEnter,
            _this.props.willLeave,
            _this.props.didLeave,
            _this.state.mergedPropsStyles,
            unreadPropStyles,
            _this.state.currentStyles,
            _this.state.currentVelocities,
            _this.state.lastIdealStyles,
            _this.state.lastIdealVelocities,
          ),
          mergedPropsStyles = _mergeAndSync[0],
          currentStyles = _mergeAndSync[1],
          currentVelocities = _mergeAndSync[2],
          lastIdealStyles = _mergeAndSync[3],
          lastIdealVelocities = _mergeAndSync[4];

        for (var i = 0; i < unreadPropStyles.length; i++) {
          var unreadPropStyle = unreadPropStyles[i].style;
          var dirty = false;

          for (var key in unreadPropStyle) {
            if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {
              continue;
            }

            var styleValue = unreadPropStyle[key];

            if (typeof styleValue === 'number') {
              if (!dirty) {
                dirty = true;
                currentStyles[i] = _extends({}, currentStyles[i]);
                currentVelocities[i] = _extends({}, currentVelocities[i]);
                lastIdealStyles[i] = _extends({}, lastIdealStyles[i]);
                lastIdealVelocities[i] = _extends({}, lastIdealVelocities[i]);
                mergedPropsStyles[i] = {
                  key: mergedPropsStyles[i].key,
                  data: mergedPropsStyles[i].data,
                  style: _extends({}, mergedPropsStyles[i].style),
                };
              }

              currentStyles[i][key] = styleValue;
              currentVelocities[i][key] = 0;
              lastIdealStyles[i][key] = styleValue;
              lastIdealVelocities[i][key] = 0;
              mergedPropsStyles[i].style[key] = styleValue;
            }
          }
        } // unlike the other 2 components, we can't detect staleness and optionally
        // opt out of setState here. each style object's data might contain new
        // stuff we're not/cannot compare

        _this.setState({
          currentStyles: currentStyles,
          currentVelocities: currentVelocities,
          mergedPropsStyles: mergedPropsStyles,
          lastIdealStyles: lastIdealStyles,
          lastIdealVelocities: lastIdealVelocities,
        });
      };

      _this.startAnimationIfNecessary = function() {
        if (_this.unmounting || _this.animationID != null) {
          return;
        } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and
        // call cb? No, otherwise accidental parent rerender causes cb trigger

        _this.animationID = raf_1(function(timestamp) {
          // https://github.com/chenglou/react-motion/pull/420
          // > if execution passes the conditional if (this.unmounting), then
          // executes async defaultRaf and after that component unmounts and after
          // that the callback of defaultRaf is called, then setState will be called
          // on unmounted component.
          if (_this.unmounting) {
            return;
          }

          var propStyles = _this.props.styles;
          var destStyles =
            typeof propStyles === 'function'
              ? propStyles(
                  rehydrateStyles(
                    _this.state.mergedPropsStyles,
                    _this.unreadPropStyles,
                    _this.state.lastIdealStyles,
                  ),
                )
              : propStyles; // check if we need to animate in the first place

          if (
            shouldStopAnimationAll$1(
              _this.state.currentStyles,
              destStyles,
              _this.state.currentVelocities,
              _this.state.mergedPropsStyles,
            )
          ) {
            // no need to cancel animationID here; shouldn't have any in flight
            _this.animationID = null;
            _this.accumulatedTime = 0;
            return;
          }

          var currentTime = timestamp || performanceNow();
          var timeDelta = currentTime - _this.prevTime;
          _this.prevTime = currentTime;
          _this.accumulatedTime = _this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart

          if (_this.accumulatedTime > msPerFrame$2 * 10) {
            _this.accumulatedTime = 0;
          }

          if (_this.accumulatedTime === 0) {
            // no need to cancel animationID here; shouldn't have any in flight
            _this.animationID = null;

            _this.startAnimationIfNecessary();

            return;
          }

          var currentFrameCompletion =
            (_this.accumulatedTime -
              Math.floor(_this.accumulatedTime / msPerFrame$2) * msPerFrame$2) /
            msPerFrame$2;
          var framesToCatchUp = Math.floor(
            _this.accumulatedTime / msPerFrame$2,
          );

          var _mergeAndSync2 = mergeAndSync(
              _this.props.willEnter,
              _this.props.willLeave,
              _this.props.didLeave,
              _this.state.mergedPropsStyles,
              destStyles,
              _this.state.currentStyles,
              _this.state.currentVelocities,
              _this.state.lastIdealStyles,
              _this.state.lastIdealVelocities,
            ),
            newMergedPropsStyles = _mergeAndSync2[0],
            newCurrentStyles = _mergeAndSync2[1],
            newCurrentVelocities = _mergeAndSync2[2],
            newLastIdealStyles = _mergeAndSync2[3],
            newLastIdealVelocities = _mergeAndSync2[4];

          for (var i = 0; i < newMergedPropsStyles.length; i++) {
            var newMergedPropsStyle = newMergedPropsStyles[i].style;
            var newCurrentStyle = {};
            var newCurrentVelocity = {};
            var newLastIdealStyle = {};
            var newLastIdealVelocity = {};

            for (var key in newMergedPropsStyle) {
              if (
                !Object.prototype.hasOwnProperty.call(newMergedPropsStyle, key)
              ) {
                continue;
              }

              var styleValue = newMergedPropsStyle[key];

              if (typeof styleValue === 'number') {
                newCurrentStyle[key] = styleValue;
                newCurrentVelocity[key] = 0;
                newLastIdealStyle[key] = styleValue;
                newLastIdealVelocity[key] = 0;
              } else {
                var newLastIdealStyleValue = newLastIdealStyles[i][key];
                var newLastIdealVelocityValue = newLastIdealVelocities[i][key];

                for (var j = 0; j < framesToCatchUp; j++) {
                  var _stepper = stepper(
                    msPerFrame$2 / 1000,
                    newLastIdealStyleValue,
                    newLastIdealVelocityValue,
                    styleValue.val,
                    styleValue.stiffness,
                    styleValue.damping,
                    styleValue.precision,
                  );

                  newLastIdealStyleValue = _stepper[0];
                  newLastIdealVelocityValue = _stepper[1];
                }

                var _stepper2 = stepper(
                    msPerFrame$2 / 1000,
                    newLastIdealStyleValue,
                    newLastIdealVelocityValue,
                    styleValue.val,
                    styleValue.stiffness,
                    styleValue.damping,
                    styleValue.precision,
                  ),
                  nextIdealX = _stepper2[0],
                  nextIdealV = _stepper2[1];

                newCurrentStyle[key] =
                  newLastIdealStyleValue +
                  (nextIdealX - newLastIdealStyleValue) *
                    currentFrameCompletion;
                newCurrentVelocity[key] =
                  newLastIdealVelocityValue +
                  (nextIdealV - newLastIdealVelocityValue) *
                    currentFrameCompletion;
                newLastIdealStyle[key] = newLastIdealStyleValue;
                newLastIdealVelocity[key] = newLastIdealVelocityValue;
              }
            }

            newLastIdealStyles[i] = newLastIdealStyle;
            newLastIdealVelocities[i] = newLastIdealVelocity;
            newCurrentStyles[i] = newCurrentStyle;
            newCurrentVelocities[i] = newCurrentVelocity;
          }

          _this.animationID = null; // the amount we're looped over above

          _this.accumulatedTime -= framesToCatchUp * msPerFrame$2;

          _this.setState({
            currentStyles: newCurrentStyles,
            currentVelocities: newCurrentVelocities,
            lastIdealStyles: newLastIdealStyles,
            lastIdealVelocities: newLastIdealVelocities,
            mergedPropsStyles: newMergedPropsStyles,
          });

          _this.unreadPropStyles = null;

          _this.startAnimationIfNecessary();
        });
      };

      _this.state = _this.defaultState();
      return _this;
    }

    var _proto = TransitionMotion.prototype;

    _proto.defaultState = function defaultState() {
      var _this$props = this.props,
        defaultStyles = _this$props.defaultStyles,
        styles = _this$props.styles,
        willEnter = _this$props.willEnter,
        willLeave = _this$props.willLeave,
        didLeave = _this$props.didLeave;
      var destStyles =
        typeof styles === 'function' ? styles(defaultStyles) : styles; // this is special. for the first time around, we don't have a comparison
      // between last (no last) and current merged props. we'll compute last so:
      // say default is {a, b} and styles (dest style) is {b, c}, we'll
      // fabricate last as {a, b}

      var oldMergedPropsStyles;

      if (defaultStyles == null) {
        oldMergedPropsStyles = destStyles;
      } else {
        oldMergedPropsStyles = defaultStyles.map(function(defaultStyleCell) {
          // TODO: key search code
          for (var i = 0; i < destStyles.length; i++) {
            if (destStyles[i].key === defaultStyleCell.key) {
              return destStyles[i];
            }
          }

          return defaultStyleCell;
        });
      }

      var oldCurrentStyles =
        defaultStyles == null
          ? destStyles.map(function(s) {
              return stripStyle(s.style);
            })
          : defaultStyles.map(function(s) {
              return stripStyle(s.style);
            });
      var oldCurrentVelocities =
        defaultStyles == null
          ? destStyles.map(function(s) {
              return mapToZero(s.style);
            })
          : defaultStyles.map(function(s) {
              return mapToZero(s.style);
            });

      var _mergeAndSync3 = mergeAndSync(
          // Because this is an old-style createReactClass component, Flow doesn't
          // understand that the willEnter and willLeave props have default values
          // and will always be present.
          willEnter,
          willLeave,
          didLeave,
          oldMergedPropsStyles,
          destStyles,
          oldCurrentStyles,
          oldCurrentVelocities,
          oldCurrentStyles, // oldLastIdealStyles really
          oldCurrentVelocities, // oldLastIdealVelocities really
        ),
        mergedPropsStyles = _mergeAndSync3[0],
        currentStyles = _mergeAndSync3[1],
        currentVelocities = _mergeAndSync3[2],
        lastIdealStyles = _mergeAndSync3[3],
        lastIdealVelocities = _mergeAndSync3[4];

      return {
        currentStyles: currentStyles,
        currentVelocities: currentVelocities,
        lastIdealStyles: lastIdealStyles,
        lastIdealVelocities: lastIdealVelocities,
        mergedPropsStyles: mergedPropsStyles,
      };
    }; // after checking for unreadPropStyles != null, we manually go set the
    // non-interpolating values (those that are a number, without a spring
    // config)

    _proto.componentDidMount = function componentDidMount() {
      this.prevTime = performanceNow();
      this.startAnimationIfNecessary();
    };

    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(
      props,
    ) {
      if (this.unreadPropStyles) {
        // previous props haven't had the chance to be set yet; set them here
        this.clearUnreadPropStyle(this.unreadPropStyles);
      }

      var styles = props.styles;

      if (typeof styles === 'function') {
        this.unreadPropStyles = styles(
          rehydrateStyles(
            this.state.mergedPropsStyles,
            this.unreadPropStyles,
            this.state.lastIdealStyles,
          ),
        );
      } else {
        this.unreadPropStyles = styles;
      }

      if (this.animationID == null) {
        this.prevTime = performanceNow();
        this.startAnimationIfNecessary();
      }
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.unmounting = true;

      if (this.animationID != null) {
        raf_1.cancel(this.animationID);
        this.animationID = null;
      }
    };

    _proto.render = function render() {
      var hydratedStyles = rehydrateStyles(
        this.state.mergedPropsStyles,
        this.unreadPropStyles,
        this.state.currentStyles,
      );
      var renderedChildren = this.props.children(hydratedStyles);
      return renderedChildren && React.Children.only(renderedChildren);
    };

    return TransitionMotion;
  })(React.Component);

  TransitionMotion.defaultProps = {
    willEnter: function willEnter(styleThatEntered) {
      return stripStyle(styleThatEntered.style);
    },
    // recall: returning null makes the current unmounting TransitionStyle
    // disappear immediately
    willLeave: function willLeave() {
      return null;
    },
    didLeave: function didLeave() {},
  };
  TransitionMotion.propTypes = {
    defaultStyles: propTypes.arrayOf(
      propTypes.shape({
        key: propTypes.string.isRequired,
        data: propTypes.any,
        style: propTypes.objectOf(propTypes.number).isRequired,
      }),
    ),
    styles: propTypes.oneOfType([
      propTypes.func,
      propTypes.arrayOf(
        propTypes.shape({
          key: propTypes.string.isRequired,
          data: propTypes.any,
          style: propTypes.objectOf(
            propTypes.oneOfType([propTypes.number, propTypes.object]),
          ).isRequired,
        }),
      ),
    ]).isRequired,
    children: propTypes.func.isRequired,
    willEnter: propTypes.func,
    willLeave: propTypes.func,
    didLeave: propTypes.func,
  };

  var presets = {
    noWobble: {
      stiffness: 170,
      damping: 26,
    },
    // the default, if nothing provided
    gentle: {
      stiffness: 120,
      damping: 14,
    },
    wobbly: {
      stiffness: 180,
      damping: 12,
    },
    stiff: {
      stiffness: 210,
      damping: 20,
    },
  };

  var defaultConfig = _extends({}, presets.noWobble, {
    precision: 0.01,
  });

  function spring(val, config) {
    return _extends({}, defaultConfig, config, {
      val: val,
    });
  }

  var hasWarned = false;
  function reorderKeys() {
    {
      if (!hasWarned) {
        hasWarned = true;
        console.error(
          "`reorderKeys` has been removed, since it is no longer needed for TransitionMotion's new styles array API.",
        );
      }
    }
  }

  exports.Motion = Motion;
  exports.StaggeredMotion = StaggeredMotion;
  exports.TransitionMotion = TransitionMotion;
  exports.spring = spring;
  exports.presets = presets;
  exports.stripStyle = stripStyle;
  exports.reorderKeys = reorderKeys;

  Object.defineProperty(exports, '__esModule', { value: true });
});
